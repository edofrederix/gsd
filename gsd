#!/bin/bash
############################################################################
#
#  This script provides a utility to show and modify a TODO file. The
#  location the TODO file is specified in this script.
#
#  Copyright (C) 2011  Jason Graham <jgraha8@gmail.com>
#
#  This file is part of todo
#
#  todo is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  todo is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with todo.  If not, see <http://www.gnu.org/licenses/>.
#
############################################################################

SCRIPTNAME=`basename "$0"`
TODOFILE="$HOME/.todo"
TODOVERSION="cvs"

#####################################################################
# STDOUT PRINT FUNCTIONS
#####################################################################

#---------------------------------------------------------------------
# PRINT_USAGE_MESSAGE
#---------------------------------------------------------------------

function print_usage_message {
    echo "Usage: $SCRIPTNAME command [command-options-and-arguments]"
    echo "Commands:"
    echo "  help                      Print this message"
    echo "  show, -s                  Show TODO entries"
    echo "    Options:"
    echo "      -n                    Show only entries with status new"
    echo "      -i                    Show only entries with status incomplete"
    echo "      -c                    Show only entries with status complete"
    echo "      -h                    Print this message"
    echo "  edit, -e                  Edit TODO entries"
    echo "    Options:"
    echo "      -a <statement>        Add entry"
    echo "      -s {N|I|C} <tag>      Change status of entry"
    echo "      -m <statement>        Change entry statement"
    echo "      -d <tag>              Delete entry"
    echo "      -r                    Reorder entry tags"
    echo "      -f <tag>              Toggle important flag"
    echo "      -h                    Print this message"
    echo "  print, -p                 Send TODO entries to printer"
    echo "    Options:"
    echo "      -n                    Print only entries with status new"
    echo "      -i                    Print only entries with status incomplete"
    echo "      -c                    Print only entries with status complete"
    echo "      -h                    Print this message"
    echo "  version, -v               Show TODO version"
    exit 0
}

#---------------------------------------------------------------------
# PRINT_VERSION
#---------------------------------------------------------------------

function print_version {
    echo "$SCRIPTNAME: version $TODOVERSION"
    exit 0
}

#---------------------------------------------------------------------
# PRINT_ERROR_MESSAGE
#---------------------------------------------------------------------

function print_error_message {
    echo "$SCRIPTNAME: $1"
    exit -1
}

#---------------------------------------------------------------------
# PRINT_ENTRY_DIVIDER
#---------------------------------------------------------------------

function print_entry_divider {
    # echo "======================================================================"
    # echo "//////////////////////////////////////////////////////////////////////"
    echo "----------------------------------------------------------------------"
    # echo "######################################################################"
    # echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
    # echo "**********************************************************************"
    # echo "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    # echo "<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>"
    # echo " "
}

#---------------------------------------------------------------------
# PRINT_ENTRY
#---------------------------------------------------------------------

function print_entry {

    print_entry_divider
    # Indent one space
    echo -n " "
    echo $1
    return 0
}

######################################################################
# LINE EXTRACTION FUNCTIONS
######################################################################

#-------------------------------------------------------------------
# PRINT_ENTRY_TAG
#--------------------------------------------------------------------

function print_entry_tag {
    local _line="$1"
    local _tag

    _tag="`echo $_line | cut -d ':' -f 1`"
    echo $_tag
}

#-------------------------------------------------------------------
# PRINT_ENTRY_STATUS
#--------------------------------------------------------------------

function print_entry_status {
    local _line="$1"
    local _status

    _status="`echo $_line | cut -d ':' -f 2`"
    echo $_status
}

#-------------------------------------------------------------------
# PRINT_ENTRY_STATEMENT
#--------------------------------------------------------------------

function print_entry_statement {


    # This function assumes that a valid line is provided
    local  _line="$1"
    local _tag
    local _status
    local _statement

    _tag=$(print_entry_tag "$_line")
    _status=$(print_entry_status "$_line")

    # Trim front material; avoiding the usage of soley : as a
    # delimiter so it can exist in text
    _statement=${_line#"$_tag:$_status: "}
    echo $_statement

}

######################################################################
# LINE CHECKING FUNCTIONS
######################################################################

#-------------------------------------------------------------------
# CHECK_IMPORTANT_FLAG
#--------------------------------------------------------------------

function check_important_flag {
    # For safety only valid statements should call this
    local _line="$1"
    local _statement

    _statement=$(print_entry_statement "$_line")

    # First see if the statement is marked as important
    if [[ "$_statement" == *'(*)'* ]]; then
        return 1
    else
        return 0
    fi
}


#-------------------------------------------------------------------
# CHECK_LINE_TYPE
#--------------------------------------------------------------------

function check_line_type {

    # This function uses special formatting rules of TODO
    local _line="$1"
    local _status
    local _statement
    local _firstchar
    local _linelength=${#_line}
    local _type
    local _flagged

#    echo $_line

    _firstchar=${_line::1}

    if [ $_linelength -eq 0 ]; then
        # Treating as blank line
        return 0
    elif [[ "$_firstchar" == "#" ]]; then
        # Treating as a comment
        return 11
    fi

    # Considerd valid entry line
    _status=$(print_entry_status "$_line")
    _statement=$(print_entry_statement "$_line")

    # Check the status
    case $_status in
        "(N)")
            _type=1
            ;;
        "(I)")
            _type=2
            ;;
        "(C)")
            _type=3
            ;;
        *)
            print_error_message "line in TODO not formatted correctly"
    esac

    check_important_flag "$_statement"
    _flagged=$?

    case $_flagged in
        0)
            return $_type
            ;;
        1)
            return $((10*_type+9))
            ;;
    esac

}

#-------------------------------------------------------------------
# GET_ENTRY_LINE_NUMBER
#--------------------------------------------------------------------

function get_entry_line_number {

    # This function will exit on error

    local _tag="$1"
    local _n
    local _line
    local _ltype

    for _n in `grep -w -n "$_tag:" $TODOFILE | cut -f1 -d:`
    do

        _line=$(sed -n ${_n}p $TODOFILE)

        check_line_type "$_line"
        _ltype=$?

        # Make sure its a valid entry
        if [ $_ltype -ne 0 -a $_ltype -ne 11 ]; then
            _tagtest=$(print_entry_tag "$_line")
            [[ "$_tag" == "$_tagtest" ]] && return $_n
        fi

    done

    # Should have returned by now
    print_error_message "specified tag not found"

}

#-------------------------------------------------------------------
# PRINT_LAST_ENTRY_TAG
#-------------------------------------------------------------------

function print_last_entry_tag {

    local _ltype
    local _tag

    _tag=0
    while read line; do

        check_line_type "$line"
        _ltype=$?

        case $_ltype in
            0|11) # Blank line or comment
                ;;
            [1-3]|19|29|39)
                _tag=$(print_entry_tag "$line")
                ;;
            *)
                print_error_message "error on read"
                ;;
        esac

    done < $TODOFILE

    echo $_tag

}

######################################################################
# ACTION FUNCTIONS
######################################################################

#-------------------------------------------------------------------
# PRINT_ENTRIES
#--------------------------------------------------------------------

function print_entries {

    local _stype=$1
    local _printloc="$2"
    local _ltype
    local _line

    declare -i _printed_one
    local _printed_one=0

    while read _line; do

        check_line_type "$_line"
        _ltype=$?

        # Ignore blank or commented lines
        if [ $_ltype -ne 0 -a $_ltype -ne 11 ]; then

            _printed_one=1

            case $_stype in
                0)
                    # Print all valid entries
                    print_entry "$_line" >> "$_printloc"
                    ;;
                1)
                    [ $_ltype -eq 1 -o $_ltype -eq 19 ] && print_entry "$_line" >> "$_printloc"
                    ;;
                2)
                    [ $_ltype -eq 2 -o $_ltype -eq 29 ] && print_entry "$_line" >> "$_printloc"
                    ;;
                3)
                    [ $_ltype -eq 3 -o $_ltype -eq 39 ] && print_entry "$_line" >> "$_printloc"
                    ;;
                9)
                    [ $_ltype -eq 19 -o $_ltype -eq 29 -o $_ltype -eq 39 ] && print_entry "$_line" >> "$_printloc"
                    ;;
            esac

        fi

    done < $TODOFILE

    # Print a blank entry
    [ $_printed_one -eq 1 ] && print_entry_divider >> "$_printloc"

}

#-------------------------------------------------------------------
# PRINT_ENTRIES_TO_PRINTER
#--------------------------------------------------------------------

function print_entries_to_printer {

    local _stype=$1
    local _ltype

    rm -f $TODOFILE.tmp
    touch $TODOFILE.tmp

    [ $? -ne 0 ] && print_error_message "cannot create temporary file"

    # Print contents to temporary file
    print_entries $_stype "$TODOFILE.tmp"

    # Send to printer; requires $PRINTER to be set
    cat $TODOFILE.tmp | lpr -p

    [ $? -ne 0 ] && print_error_message "unable to print"

    rm -f $TODOFILE.tmp

}

#-------------------------------------------------------------------
# MODIFY_ENTRY_STATUS
#--------------------------------------------------------------------

function modify_entry_status {

    local _status="$1"
    local _tag="$2"

    local _statement
    local _linenumber

    #get_entry_line_number "$_tag"
    get_entry_line_number "$_tag"
    _linenumber=$?

    _line=$(sed -n ${_linenumber}p $TODOFILE)

    # Extract the statement
    _statement=$(print_entry_statement "$_line")

    # Update the entry in the todo file
    sed -i.tmp "$_linenumber c$_tag:$_status: $_statement" $TODOFILE

    if [ $? -ne 0 ]; then
        cp $TODOFILE.tmp $TODOFILE
        print_error_message "could not update entry status"
    else
        rm -f $TODOFILE.tmp
    fi

    return 0

}

#-------------------------------------------------------------------
# MODIFY_ENTRY_STATMENT
#--------------------------------------------------------------------

function modify_entry_statement {

    local _statement="$1"
    local _tag="$2"

    local _status
    local _linenumber

    #get_entry_line_number "$_tag"
    get_entry_line_number "$_tag"
    _linenumber=$?

    _line=$(sed -n ${_linenumber}p $TODOFILE)

    # Extract the status
    _status=$(print_entry_status "$_line")

    check_important_flag $(print_entry_statement "$_line")

    if [ $? -eq 1 ]; then
        _line="$_tag:$_status: (*) $_statement"
    else
        _line="$_tag:$_status: $_statement"
    fi

    # Update the entry in the todo file
    sed -i.tmp "$_linenumber c$_line" $TODOFILE

    if [ $? -ne 0 ]; then
        cp $TODOFILE.tmp $TODOFILE
        print_error_message "could not modify entry statement"
    else
        rm -f $TODOFILE.tmp
    fi

    return 0

}

#-------------------------------------------------------------------
# DELETE_ENTRY
#--------------------------------------------------------------------

function delete_entry {

    local _tag="$1"
    local _ltype
    local _testtag

    local _status
    local _linenumber

    #get_entry_line_number "$_tag"
    get_entry_line_number "$_tag"
    _linenumber=$?

    # Delete the entry in the todo file
    sed -i.tmp "$_linenumber d" $TODOFILE

    if [ $? -ne 0 ]; then
        cp $TODOFILE.tmp $TODOFILE
        print_error_message "could not delete entry"
    else
        rm -f $TODOFILE.tmp
    fi

    return 0

}

#-------------------------------------------------------------------
# REORDER_ENTRY_TAGS
#--------------------------------------------------------------------

function reorder_entry_tags {

    # This function reorders ("sequentializes") them and has the nice
    # side-effect of removing blank lines

    local _status
    local _statement
    local _ltype
    local line

    declare -i _tag

    rm -f $TODOFILE.tmp
    touch $TODOFILE.tmp

    [ $? -ne 0 ] && print_error_message "cannot create temporary file"

    _tag=0
    while read line; do

        check_line_type "$line"
        _ltype=$?

        if [ $_ltype -eq 11 ]; then
            echo "$line" >> $TODOFILE.tmp
        elif [ $_ltype -ne 0 ]; then

            # Check if this is our tag
            _tag=$((_tag+1))
            _status=$(print_entry_status "$line")
            _statement=$(print_entry_statement "$line")
            echo "$_tag:$_status: $_statement" >> $TODOFILE.tmp

        fi

    done < $TODOFILE

    cp $TODOFILE.tmp $TODOFILE
    rm -f $TODOFILE.tmp

    return 0

}

#-------------------------------------------------------------------
# TOGGLE_IMPORTANT_FLAG
#--------------------------------------------------------------------

function toggle_important_flag {

    local _tag="$1"

    local _status
    local _statement

    local _line
    local _linenumber

    get_entry_line_number "$_tag"
    _linenumber=$?

    _line=$(sed -n ${_linenumber}p $TODOFILE)

    # Extract the status
    _status=$(print_entry_status "$_line")
    _statement=$(print_entry_statement "$_line")

    # First see if the statement is marked as important
    check_important_flag "$_statement"

    if [ $? -eq 1 ]; then
        # Trim old flag
        _statement=${_statement#'(*)'}
    else
        # Add important tag
        _statement="(*) $_statement"
    fi

    # Reconstruct the line
    _line="$_tag:$_status: $_statement"

    # Update the entry in the todo file
    sed -i.tmp "$_linenumber c$_line" $TODOFILE

    if [ $? -ne 0 ]; then
        cp $TODOFILE.tmp $TODOFILE
        print_error_message "could not toggle flag"
    else
        rm -f $TODOFILE.tmp
    fi

    return 0

}

#####################################################################
# MAIN
#####################################################################

# First check that the TODO file exists and is readable
if [ ! -f $TODOFILE ]; then
    touch $TODOFILE
    [ $? -ne 0 ] && print_error_message "unable to create $TODOFILE"
fi

declare -i STYPE=0
declare -i ETYPE=0
declare -i ACTION=0

declare -i TAG_SET=0
declare -i STATUS_SET=0
declare -i STATEMENT_SET=0

NARGS=$#
if [ $NARGS -lt 1 ]; then
    print_error_message "action not specified"
fi

    # First argument should be the action
case $1 in
    "show"|"-s")
            ACTION=1
            ;;
    "edit"|"-e")
            ACTION=2
            ;;
    "print"|"-p")
            ACTION=3
            ;;
    "help"|"-h")
            print_usage_message
            ;;
    "version"|"-v")
            print_version
            ;;
    *)
            print_error_message "action not specified correctly"
            ;;
esac

    # Now handle suboptions
if [ $ACTION -eq 1 -o $ACTION -eq 3 ]; then

    if [ $NARGS -gt 1 ]; then

        if [ $NARGS -gt 2 ]; then
            print_error_message "$1 only requires only one option"
        fi

        case $2 in
            "-n")
                STYPE=1
                ;;
            "-i")
                STYPE=2
                ;;
            "-c")
                STYPE=3
                ;;
            "-f")
                STYPE=9
                ;;
            "-h")
                print_usage_message
                ;;
            *)
                print_error_message "incorrect option"
                ;;
        esac

    fi

else

    if [ $NARGS == 1 ]; then
        print_error_message "$1 requires option"
    fi

    case $2 in
        "-a")

            if [ $NARGS -ne 3 ]; then
                print_error_message "$1 $2 requires one option"
            else
                ETYPE=1
                STATEMENT=$3

                STATEMENT_SET=1
            fi
            ;;

        "-s")

            if [ $NARGS -ne 4 ]; then
                print_error_message "$1 $2 requires two options"
            else
                ETYPE=2
                STATUS_SYMB=$3
                TAG=$4

                TAG_SET=1
                STATUS_SET=1

                case $STATUS_SYMB in
                    "n"|"N")
                        STATUS="(N)"
                        ;;
                    "i"|"I")
                        STATUS="(I)"
                        ;;
                    "c"|"C")
                        STATUS="(C)"
                        ;;
                    *)
                        print_error_message "status not specified correctly"
                        ;;
                esac


            fi
            ;;


        "-d")

            if [ $NARGS -ne 3 ]; then
                print_error_message "$1 $2 requires one option"
            else
                ETYPE=3
                TAG=$3

                TAG_SET=1

            fi
            ;;

        "-r")

            if [ $NARGS -ne 2 ]; then
                print_error_message "$1 $2 takes no argument"
            else
                ETYPE=4
            fi
            ;;

        "-m")

            if [ $NARGS -ne 4 ]; then
                print_error_message "$1 $2 requires two options"
            else

                ETYPE=5
                STATEMENT=$3
                TAG=$4

                TAG_SET=1
                STATEMENT_SET=1

            fi
            ;;
        "-f")

            if [ $NARGS -ne 3 ]; then
                print_error_message "$1 $2 requires one option"
            else
                ETYPE=6
                TAG=$3
                TAG_SET=1
            fi
            ;;

        "-h")
            print_usage_message
            ;;

        *)
            print_error_message "not a valid edit option"
            ;;

    esac

fi

# Now check arguments
if [ $ACTION -eq 0 ]; then
    print_error_message "no action specified"
elif [ $ACTION -eq 1 -o $ACTION -eq 3 ]; then
    [ $ETYPE -ne 0 ] && print_error_message "do not specify edit option with option show"
elif [ $ACTION -eq 2 ]; then
    [ $STYPE -ne 0 ] && print_error_message "do not specify show option with option edit"
else
    print_error_message "incorrect action specified"
fi


if [ $ACTION -eq 1 ]; then

    print_entries $STYPE /dev/stdout

elif [ $ACTION -eq 3 ]; then

    print_entries_to_printer $STYPE

else

    case $ETYPE in

        0) #
            print_error_message "no edit option specified"
            ;;
        1)
            TAG=$(print_last_entry_tag)
            TAG=$((TAG+1))
            echo "$TAG:(N): $STATEMENT" >> $TODOFILE
            ;;
        2)
            # Need to modify entry
            [ $STATUS_SET -eq 1 -a $TAG_SET -eq 1 ] && modify_entry_status "$STATUS" "$TAG"
            ;;
        3)
            [ $TAG_SET -eq 1 ] && delete_entry "$TAG"
            ;;
        4)
            reorder_entry_tags
            ;;
        5)
            [ $STATEMENT_SET -eq 1 -a $TAG_SET -eq 1 ] && modify_entry_statement "$STATEMENT" "$TAG"
            ;;
        6)
            [ $TAG_SET -eq 1 ] && toggle_important_flag "$TAG"
            ;;
    esac


fi


exit 0
