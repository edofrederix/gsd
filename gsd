#!/bin/bash
############################################################################
#
#  This script provides a utility to show and modify a TODO file. The
#  location the TODO file is specified in this script.
#
#  Copyright (C) 2011  Jason Graham <jgraha8@gmail.com>
#
#  This file is part of todo
#
#  todo is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  todo is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with todo.  If not, see <http://www.gnu.org/licenses/>.
#
############################################################################

SCRIPTNAME=`basename "$0"`
TODOFILE="$HOME/.todo"
TODOVERSION="cvs"

#####################################################################
# STDOUT PRINT FUNCTIONS
#####################################################################

#---------------------------------------------------------------------
# PRINT_USAGE_MESSAGE
#---------------------------------------------------------------------

function print_usage_message {
    echo "Usage: $SCRIPTNAME command [command-options-and-arguments]"
    echo "Commands:"
    echo "  help                      Print this message"
    echo "  show                      Show TODO entries"
    echo "    Options:"
    echo "      -n                    Show only entries with status new"
    echo "      -i                    Show only entries with status incomplete"
    echo "      -c                    Show only entries with status complete"
    echo "      -f                    Show only flagged entries"
#    echo "      -h                    Print this message"
    echo "  add <statement>           Add new entry"
    echo "  delete <tag>              Delete entry"
    echo "  edit                      Edit TODO entries"
    echo "    Options:"
    echo "      -s {N|I|C} <tag>      Change status of entry"
    echo "      -m <statement>        Change entry statement"
    echo "      -f <tag>              Toggle important flag"
    echo "      -r                    Reorder entry tags"
#    echo "      -h                    Print this message"
    echo "  search <phrase>           Perform text search on entries"
    echo "  purge                     Remove all completed entries"
    echo "  print                     Send TODO entries to printer"
    echo "    Options:"
    echo "      -n                    Print only entries with status new"
    echo "      -i                    Print only entries with status incomplete"
    echo "      -c                    Print only entries with status complete"
    echo "      -f                    Print only flagged entries"
#    echo "      -h                    Print this message"
    echo "  version                   Show TODO version"
    exit 0
}

#---------------------------------------------------------------------
# PRINT_VERSION
#---------------------------------------------------------------------

function print_version {
    echo "$SCRIPTNAME: version $TODOVERSION"
    exit 0
}

#---------------------------------------------------------------------
# PRINT_ERROR_MESSAGE
#---------------------------------------------------------------------

function print_error_message {
    echo "$SCRIPTNAME: $1"
    exit -1
}

#---------------------------------------------------------------------
# PRINT_ENTRY_DIVIDER
#---------------------------------------------------------------------

function print_entry_divider {
    # echo "======================================================================"
    # echo "//////////////////////////////////////////////////////////////////////"
    echo "----------------------------------------------------------------------"
    # echo "######################################################################"
    # echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
    # echo "**********************************************************************"
    # echo "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    # echo "<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>"
    # echo " "
}

#---------------------------------------------------------------------
# PRINT_ENTRY
#---------------------------------------------------------------------

function print_entry {

    print_entry_divider
    # Indent one space
    echo -n " "
    echo $1
    return 0
}

######################################################################
# LINE EXTRACTION FUNCTIONS
######################################################################

#-------------------------------------------------------------------
# PRINT_ENTRY_TAG
#--------------------------------------------------------------------

function print_entry_tag {
    local _line="$1"
    local _tag

    _tag="`echo $_line | cut -d ':' -f 1`"
    echo $_tag
}

#-------------------------------------------------------------------
# PRINT_ENTRY_STATUS
#--------------------------------------------------------------------

function print_entry_status {
    local _line="$1"
    local _status

    _status="`echo $_line | cut -d ':' -f 2`"
    echo $_status
}

#-------------------------------------------------------------------
# PRINT_ENTRY_STATEMENT
#--------------------------------------------------------------------

function print_entry_statement {


    # This function assumes that a valid line is provided
    local  _line="$1"
    local _tag
    local _status
    local _statement

    _tag=$(print_entry_tag "$_line")
    _status=$(print_entry_status "$_line")

    # Trim front material; avoiding the usage of soley : as a
    # delimiter so it can exist in text
    _statement=${_line#"$_tag:$_status: "}
    echo $_statement

}

######################################################################
# LINE CHECKING FUNCTIONS
######################################################################

#-------------------------------------------------------------------
# CHECK_IMPORTANT_FLAG
#--------------------------------------------------------------------

function check_important_flag {
    # For safety only valid statements should call this
    local _line="$1"
    local _statement

    _statement=$(print_entry_statement "$_line")

    # First see if the statement is marked as important
    if [[ "$_statement" == *'(*)'* ]]; then
        return 1
    else
        return 0
    fi
}


#-------------------------------------------------------------------
# CHECK_LINE_TYPE
#--------------------------------------------------------------------

function check_line_type {

    # This function uses special formatting rules of TODO
    local _line="$1"
    local _status
    local _statement
    local _firstchar
    local _linelength=${#_line}
    local _type
    local _flagged

#    echo $_line

    _firstchar=${_line::1}

    if [ $_linelength -eq 0 ]; then
        # Treating as blank line
        return 0
    elif [[ "$_firstchar" == "#" ]]; then
        # Treating as a comment
        return 11
    fi

    # Considerd valid entry line
    _status=$(print_entry_status "$_line")
    _statement=$(print_entry_statement "$_line")

    # Check the status
    case $_status in
        "(N)")
            _type=1
            ;;
        "(I)")
            _type=2
            ;;
        "(C)")
            _type=3
            ;;
        *)
            print_error_message "line in TODO not formatted correctly"
    esac

    check_important_flag "$_statement"
    _flagged=$?

    case $_flagged in
        0)
            return $_type
            ;;
        1)
            return $((10*_type+9))
            ;;
    esac

}

#-------------------------------------------------------------------
# GET_ENTRY_LINE_NUMBER
#--------------------------------------------------------------------

function get_entry_line_number {

    # This function will exit on error

    local _tag="$1"
    local _n
    local _line
    local _ltype

    for _n in `grep -n "$_tag:" $TODOFILE | cut -f1 -d:`
    do

        _line=$(sed -n ${_n}p $TODOFILE)

        check_line_type "$_line"
        _ltype=$?

        # Make sure its a valid entry
        if [ $_ltype -ne 0 -a $_ltype -ne 11 ]; then
            _tagtest=$(print_entry_tag "$_line")
            [[ "$_tag" == "$_tagtest" ]] && return $_n
        fi

    done

    # Should have returned by now
    print_error_message "specified tag not found"

}

#-------------------------------------------------------------------
# PRINT_LAST_ENTRY_TAG
#-------------------------------------------------------------------

function print_last_entry_tag {

    local _ltype
    local _tag

    _tag=0
    while read line; do

        check_line_type "$line"
        _ltype=$?

        case $_ltype in
            0|11) # Blank line or comment
                ;;
            [1-3]|19|29|39)
                _tag=$(print_entry_tag "$line")
                ;;
            *)
                print_error_message "error on read"
                ;;
        esac

    done < $TODOFILE

    echo $_tag

}

######################################################################
# ACTION FUNCTIONS
######################################################################
#
# Each of these functions are required to be error checking and must
# exit the program using print_error_message if an error is
# encountered
#

#-------------------------------------------------------------------
# PRINT_ENTRIES
#--------------------------------------------------------------------

function print_entries {

    local _stype=$1
    local _printloc="$2"
    local _ltype
    local _line

    declare -i _printed_one
    local _printed_one=0

    while read _line; do

        check_line_type "$_line"
        _ltype=$?

        # Ignore blank or commented lines
        if [ $_ltype -ne 0 -a $_ltype -ne 11 ]; then

            _printed_one=1

            case $_stype in
                0)
                    # Print all valid entries
                    print_entry "$_line" >> "$_printloc"
                    ;;
                1)
                    [ $_ltype -eq 1 -o $_ltype -eq 19 ] && print_entry "$_line" >> "$_printloc"
                    ;;
                2)
                    [ $_ltype -eq 2 -o $_ltype -eq 29 ] && print_entry "$_line" >> "$_printloc"
                    ;;
                3)
                    [ $_ltype -eq 3 -o $_ltype -eq 39 ] && print_entry "$_line" >> "$_printloc"
                    ;;
                9)
                    [ $_ltype -eq 19 -o $_ltype -eq 29 -o $_ltype -eq 39 ] && print_entry "$_line" >> "$_printloc"
                    ;;
            esac

        fi

    done < $TODOFILE

    # Print a blank entry
    [ $_printed_one -eq 1 ] && print_entry_divider >> "$_printloc"

}

#-------------------------------------------------------------------
# PRINT_ENTRIES_TO_PRINTER
#--------------------------------------------------------------------

function print_entries_to_printer {

    local _stype=$1
    local _ltype

    rm -f $TODOFILE.tmp
    touch $TODOFILE.tmp

    [ $? -ne 0 ] && print_error_message "cannot create temporary file"

    # Print contents to temporary file
    print_entries $_stype "$TODOFILE.tmp"

    # Send to printer; requires $PRINTER to be set
    cat $TODOFILE.tmp | lpr -p

    [ $? -ne 0 ] && print_error_message "unable to print"

    rm -f $TODOFILE.tmp

}

#-------------------------------------------------------------------
# MODIFY_ENTRY_STATUS
#--------------------------------------------------------------------

function modify_entry_status {

    local _status="$1"
    local _tag="$2"

    local _statement
    local _linenumber

    #get_entry_line_number "$_tag"
    get_entry_line_number "$_tag"
    _linenumber=$?

    _line=$(sed -n ${_linenumber}p $TODOFILE)

    # Extract the statement
    _statement=$(print_entry_statement "$_line")

    # Update the entry in the todo file
    sed -i.tmp "$_linenumber c$_tag:$_status: $_statement" $TODOFILE

    if [ $? -ne 0 ]; then
        cp $TODOFILE.tmp $TODOFILE
        print_error_message "could not update entry status"
    else
        rm -f $TODOFILE.tmp
    fi

    return 0

}

#-------------------------------------------------------------------
# MODIFY_ENTRY_STATMENT
#--------------------------------------------------------------------

function modify_entry_statement {

    local _statement="$1"
    local _tag="$2"

    local _status
    local _linenumber

    #get_entry_line_number "$_tag"
    get_entry_line_number "$_tag"
    _linenumber=$?

    _line=$(sed -n ${_linenumber}p $TODOFILE)

    # Extract the status
    _status=$(print_entry_status "$_line")

    check_important_flag $(print_entry_statement "$_line")

    if [ $? -eq 1 ]; then
        _line="$_tag:$_status: (*) $_statement"
    else
        _line="$_tag:$_status: $_statement"
    fi

    # Update the entry in the todo file
    sed -i.tmp "$_linenumber c$_line" $TODOFILE

    if [ $? -ne 0 ]; then
        cp $TODOFILE.tmp $TODOFILE
        print_error_message "could not modify entry statement"
    else
        rm -f $TODOFILE.tmp
    fi

    return 0

}

#-------------------------------------------------------------------
# ADD_ENTRY
#--------------------------------------------------------------------

function add_entry {

    local _statement="$1"
    local _tag

    _tag=$(print_last_entry_tag)
    _tag=$((_tag+1))
    echo "$_tag:(N): $_statement" >> $TODOFILE

    if [ $? -eq 0 ]; then
        return 0
    else
        print_error_message "unable to add new entry"
    fi

}

#-------------------------------------------------------------------
# DELETE_ENTRY
#--------------------------------------------------------------------

function delete_entry {

    local _tag="$1"
    local _ltype
    local _testtag

    local _status
    local _linenumber

    #get_entry_line_number "$_tag"
    get_entry_line_number "$_tag"
    _linenumber=$?

    # Delete the entry in the todo file
    sed -i.tmp "$_linenumber d" $TODOFILE

    if [ $? -ne 0 ]; then
        cp $TODOFILE.tmp $TODOFILE
        print_error_message "could not delete entry"
    else
        rm -f $TODOFILE.tmp
    fi

    return 0

}

#-------------------------------------------------------------------
# SEARCH_PHRASE_ENTRIES
#--------------------------------------------------------------------

function search_phrase_entries {

    local _phrase="$1"
    local _n
    local _line
    local _ltype

    local _found_one=0

    for _n in `grep -i -n "$_phrase" $TODOFILE | cut -f1 -d:`
    do

        _line=$(sed -n ${_n}p $TODOFILE)

        check_line_type "$_line"
        _ltype=$?

        [ $_ltype -ne 0 -a $_ltype -ne 11 ] && _found_one=1 && print_entry "$_line" /dev/stdout

    done

    [ $_found_one -eq 1 ] && print_entry_divider

    return 0

}

#-------------------------------------------------------------------
# PURGE_COMPLETED_ENTRIES
#--------------------------------------------------------------------

function purge_completed_entries {

    local _ltype
    local _line

    # Get all suspicious lines; notice the sort -nr at the end - we
    # must delete them in reverse order other wise we'll delete the
    # wrong lines since things are shifted upwards after a delete
    for _linenumber in `grep -n ":(C):" $TODOFILE | cut -f1 -d: | sort -nr`
    do
        # Read the line
        _line=$(sed -n ${_linenumber}p $TODOFILE)

        check_line_type "$_line"
        _ltype=$?

        # Make sure its a valid entry
        if [ $_ltype -eq 3 -o $_ltype -eq 39 ]; then

            # Delete the entry in the todo file
            sed -i.tmp "$_linenumber d" $TODOFILE

            if [ $? -ne 0 ]; then
                cp $TODOFILE.tmp $TODOFILE
                print_error_message "could not delete entry"
            else

                rm -f $TODOFILE.tmp

            fi

        fi

    done

    return 0

}

#-------------------------------------------------------------------
# REORDER_ENTRY_TAGS
#--------------------------------------------------------------------

function reorder_entry_tags {

    # This function reorders ("sequentializes") them and has the nice
    # side-effect of removing blank lines

    local _status
    local _statement
    local _ltype
    local line

    declare -i _tag

    rm -f $TODOFILE.tmp
    touch $TODOFILE.tmp

    [ $? -ne 0 ] && print_error_message "cannot create temporary file"

    _tag=0
    while read line; do

        check_line_type "$line"
        _ltype=$?

        if [ $_ltype -eq 11 ]; then
            echo "$line" >> $TODOFILE.tmp
        elif [ $_ltype -ne 0 ]; then

            # Check if this is our tag
            _tag=$((_tag+1))
            _status=$(print_entry_status "$line")
            _statement=$(print_entry_statement "$line")
            echo "$_tag:$_status: $_statement" >> $TODOFILE.tmp

        fi

    done < $TODOFILE

    cp $TODOFILE.tmp $TODOFILE
    rm -f $TODOFILE.tmp

    return 0

}

#-------------------------------------------------------------------
# TOGGLE_IMPORTANT_FLAG
#--------------------------------------------------------------------

function toggle_important_flag {

    local _tag="$1"

    local _status
    local _statement

    local _line
    local _linenumber

    get_entry_line_number "$_tag"
    _linenumber=$?

    _line=$(sed -n ${_linenumber}p $TODOFILE)

    # Extract the status
    _status=$(print_entry_status "$_line")
    _statement=$(print_entry_statement "$_line")

    # First see if the statement is marked as important
    check_important_flag "$_statement"

    if [ $? -eq 1 ]; then
        # Trim old flag
        _statement=${_statement#'(*)'}
    else
        # Add important tag
        _statement="(*) $_statement"
    fi

    # Reconstruct the line
    _line="$_tag:$_status: $_statement"

    # Update the entry in the todo file
    sed -i.tmp "$_linenumber c$_line" $TODOFILE

    if [ $? -ne 0 ]; then
        cp $TODOFILE.tmp $TODOFILE
        print_error_message "could not toggle flag"
    else
        rm -f $TODOFILE.tmp
    fi

    return 0

        }

#####################################################################
# MAIN
#####################################################################

# First check that the TODO file exists and is readable
        if [ ! -f $TODOFILE ]; then
            touch $TODOFILE
            [ $? -ne 0 ] && print_error_message "unable to create $TODOFILE"
        fi

        declare -i STYPE=0
        declare -i ETYPE=0
        declare -i ACTION=0

        NARGS=$#
        if [ $NARGS -lt 1 ]; then
            print_error_message "action not specified"
        fi

    # First argument should be the action
        case $1 in
            "show"|"-s")
ACTION=1
;;
"add"|"-a")
ACTION=2
;;
"delete"|"-d")
ACTION=3
;;
"edit"|"-e")
ACTION=4
;;
"search")
ACTION=5
;;
"purge")
ACTION=6
;;
"print"|"-p")
ACTION=9
;;
"help"|"-h")
print_usage_message
;;
"version"|"-v")
print_version
;;
*)
print_error_message "action not specified correctly"
;;
esac

# Now handle suboptions
if [ $ACTION -eq 0 ]; then

    print_error_message "no action specified"

elif [ $ACTION -eq 1 -o $ACTION -eq 9 ]; then

    # Showing or printing
    if [ $NARGS -gt 1 ]; then

        if [ $NARGS -gt 2 ]; then
            print_error_message "$1 only requires only one option"
        fi

        case $2 in
            "-n")
            STYPE=1
            ;;
            "-i")
            STYPE=2
            ;;
            "-c")
            STYPE=3
            ;;
            "-f")
            STYPE=9
            ;;
            "-h")
            print_usage_message
            ;;
            *)
            print_error_message "incorrect option"
            ;;
        esac

    fi

    if [ $ACTION -eq 1 ]; then

        print_entries $STYPE /dev/stdout

    else

        print_entries_to_printer $STYPE

    fi

elif [ $ACTION -eq 2 ]; then

    [ $NARGS -ne 2 ] && print_error_message "$1 requires <tag>"
    # Append new entry
    add_entry "$2"

elif [ $ACTION -eq 3 ]; then

    [ $NARGS -ne 2 ] && print_error_message "$1 requires <tag>"

    delete_entry "$2"

elif [ $ACTION -eq 4 ]; then

    # Edit entry

    if [ $NARGS == 1 ]; then
        print_error_message "$1 requires at least option"
    fi

    case $2 in

        "-s")

        if [ $NARGS -ne 4 ]; then
            print_error_message "$1 $2 requires <status> <tag>"
        else

            STATUS_SYMB=$3
            TAG=$4

            case $STATUS_SYMB in
                "n"|"N")
                STATUS="(N)"
                ;;
                "i"|"I")
                STATUS="(I)"
                ;;
                "c"|"C")
                STATUS="(C)"
                ;;
                *)
                print_error_message "status not specified correctly"
                ;;
            esac


        fi

            # Modify entry
        modify_entry_status "$STATUS" "$TAG"
        ;;

        "-m")

        if [ $NARGS -ne 4 ]; then
            print_error_message "$1 $2 requires <statement> <tag>"
        else

            STATEMENT=$3
            TAG=$4

            modify_entry_statement "$STATEMENT" "$TAG"

        fi
        ;;

        "-f")

        if [ $NARGS -ne 3 ]; then
            print_error_message "$1 $2 requires <tag>"
        else

            TAG=$3
            toggle_important_flag "$TAG"

        fi
        ;;

        "-r")
        reorder_entry_tags
        ;;

        "-h")
        print_usage_message
        ;;

        *)
        print_error_message "not a valid edit option"
        ;;

    esac

elif [ $ACTION -eq 5 ]; then

    [ $NARGS -ne 2 ] && print_error_message "$1 requires search phrase"
    search_phrase_entries "$2"

elif [ $ACTION -eq 6 ]; then

    [ $NARGS -ne 1 ] && print_error_message "$1 takes no arguments"
    # Purge all entries with status complete
    purge_completed_entries

else

    print_error_message "action not specified correctly"

fi

exit 0
